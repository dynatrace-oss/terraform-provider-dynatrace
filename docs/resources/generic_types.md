---
layout: ""
page_title: "dynatrace_generic_types Resource - terraform-provider-dynatrace"
subcategory: "Topology Model"
description: |-
  The resource `dynatrace_generic_types` covers configuration for custom topology generic types
---

# dynatrace_generic_types (Resource)

-> This resource requires the API token scopes **Read settings** (`settings.read`) and **Write settings** (`settings.write`)

## Dynatrace Documentation

- Define custom topology - https://www.dynatrace.com/support/help/extend-dynatrace/extend-topology/custom-topology

- Settings API - https://www.dynatrace.com/support/help/dynatrace-api/environment-api/settings (schemaId: `builtin:monitoredentities.generic.type`)

## Export Example Usage

- `terraform-provider-dynatrace -export dynatrace_generic_types` downloads all existing custom topology generic types configuration

The full documentation of the export feature is available [here](https://registry.terraform.io/providers/dynatrace-oss/dynatrace/latest/docs/guides/export-v2).

## Resource Example Usage

```terraform
resource "dynatrace_generic_types" "#name#" {
  name         = "terraform:type"
  enabled      = true
  created_by   = "Terraform"
  display_name = "TerraformTest"
  rules {
    rule {
      icon_pattern          = "{TerraformIcon}"
      id_pattern            = "{TerraformPlaceholder}"
      instance_name_pattern = "{TerraformInstance}"
      attributes {
        attribute {
          key     = "TerraformAttribute"
          pattern = "{TerraformExtraction}"
        }
      }
      required_dimensions {
        required_dimension {
          key = "TerraformDimension"
        }
      }
      sources {
        source {
          condition   = "$eq(TerraformCondition)"
          source_type = "Events"
        }
      }
    }
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `created_by` (String) The user or extension that created this type.
- `display_name` (String) The human readable type name for this entity type.
- `enabled` (Boolean) This setting is enabled (`true`) or disabled (`false`)
- `name` (String) The entity type name. This type name must be unique and must not be changed after creation.
- `rules` (Block List, Min: 1, Max: 1) Specify a list of rules which are evaluated in order. When **any** rule matches, the entity defined according to that rule will be extracted. Subsequent rules will not be evaluated. (see [below for nested schema](#nestedblock--rules))

### Optional

- `insert_after` (String) Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched

### Read-Only

- `id` (String) The ID of this resource.

<a id="nestedblock--rules"></a>
### Nested Schema for `rules`

Required:

- `rule` (Block List, Min: 1) (see [below for nested schema](#nestedblock--rules--rule))

<a id="nestedblock--rules--rule"></a>
### Nested Schema for `rules.rule`

Required:

- `id_pattern` (String) ID patterns are comprised of static text and placeholders referring to dimensions in the ingest data. An ID pattern **must** contain at least one placeholder to ensure that different entities will be created.. Take care that the pattern results in the same ID for the same entity. For example, using timestamp or counter-like dimensions as part of the ID would lead to the creation of new entities for each ingest data and is strongly discouraged!

Each dimension key referred to by an identifier placeholder must be present in order to extract an entity. If any dimension key referred to in the identifier is missing, the rule will not be considered for evaluation. If you have cases where you still want to extract the same entity type but have differently named keys, consider creating multiple rules extracting the same entity type. In this case take care that each ID pattern evaluates to the same value if the same entity should be extracted.
- `sources` (Block List, Min: 1, Max: 1) Specify all sources which should be evaluated for this rule. A rule is evaluated if any of the specified source filters match. (see [below for nested schema](#nestedblock--rules--rule--sources))

Optional:

- `attributes` (Block List, Max: 1) All attribute extraction rules will be applied and found attributes will be added to the extracted type. (see [below for nested schema](#nestedblock--rules--rule--attributes))
- `icon_pattern` (String) Define a pattern which is used to set the icon attribute of the entity. The extracted values must reference barista icon ids. You may define placeholders referencing data source dimensions.
- `instance_name_pattern` (String) Define a pattern which is used to set the name attribute of the entity. You may define placeholders referencing data source dimensions.
- `required_dimensions` (Block List, Max: 1) In addition to the dimensions already referred to in the ID pattern, you may specify additional dimensions which must be present in order to evaluate this rule. (see [below for nested schema](#nestedblock--rules--rule--required_dimensions))
- `role` (String) If you want to extract multiple entities of the same type from a single ingest line you need to define multiple rules with different roles.

<a id="nestedblock--rules--rule--sources"></a>
### Nested Schema for `rules.rule.sources`

Required:

- `source` (Block Set, Min: 1) (see [below for nested schema](#nestedblock--rules--rule--sources--source))

<a id="nestedblock--rules--rule--sources--source"></a>
### Nested Schema for `rules.rule.sources.source`

Required:

- `source_type` (String) Possible Values: `BusinessEvents`, `Entities`, `Events`, `Logs`, `Metrics`, `Spans`, `Topology`

Optional:

- `condition` (String) Specify a filter that needs to match in order for the extraction to happen.. Three different filters are supported: `$eq(value)` will ensure that the source matches exactly 'value', `$prefix(value)` will ensure that the source begins with exactly 'value', '$exists()' will ensure that any source with matching dimension filter exists.
If your value contains the characters '(', ')' or '\~', you need to escape them by adding a '\~' in front of them.



<a id="nestedblock--rules--rule--attributes"></a>
### Nested Schema for `rules.rule.attributes`

Required:

- `attribute` (Block Set, Min: 1) (see [below for nested schema](#nestedblock--rules--rule--attributes--attribute))

<a id="nestedblock--rules--rule--attributes--attribute"></a>
### Nested Schema for `rules.rule.attributes.attribute`

Required:

- `key` (String) The attribute key is the unique name of the attribute.
- `pattern` (String) Pattern for specifying the value for the extracted attribute. Can be a static value, placeholders or a combination of both.

Optional:

- `display_name` (String) The human readable attribute name for this extraction rule. Leave blank to use the key as the display name.



<a id="nestedblock--rules--rule--required_dimensions"></a>
### Nested Schema for `rules.rule.required_dimensions`

Required:

- `required_dimension` (Block Set, Min: 1) (see [below for nested schema](#nestedblock--rules--rule--required_dimensions--required_dimension))

<a id="nestedblock--rules--rule--required_dimensions--required_dimension"></a>
### Nested Schema for `rules.rule.required_dimensions.required_dimension`

Required:

- `key` (String) A dimension key which needs to exist in the ingest data to match this filter.

Optional:

- `value_pattern` (String) A dimension value pattern which needs to exist in the ingest data to match this filter.
 